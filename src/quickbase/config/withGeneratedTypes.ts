// QuickBase Config with Generated Types - Enhanced type integration

import type { QuickBaseConfig, QuickBaseClient } from '../types/index.js'
import { createQuickBaseClient } from '../index.js'

// Import generated types - these would be auto-generated by the scripts/generate.ts
// For example: import type { BgSoftwareApp } from '../../types/generated/index.js'

/**
 * Creates a strongly typed QuickBase client with generated type support
 * This function will be enhanced as types are generated
 */
export function createTypedQuickBaseClient<TApps extends Record<string, any> = any>(
  config: QuickBaseConfig
): QuickBaseClient & {
  // This will be enhanced with generated app-specific methods
  // Example: bgSoftware: TypedAppOperations<BgSoftwareApp>
} {
  const client = createQuickBaseClient(config)
  
  // Add typed operations for each app
  // This would be populated by the type generation process
  const typedClient = client as any
  
  // Example of how generated types would be integrated:
  /*
  if (config.apps.find(app => app.name === 'BG_SOFTWARE')) {
    typedClient.bgSoftware = {
      users: {
        find: (options: Omit<FindOptions, 'table'>) => 
          client.find({ ...options, table: 'users' }),
        findByID: (options: Omit<FindByIDOptions, 'table'>) => 
          client.findByID({ ...options, table: 'users' }),
        create: (options: Omit<CreateOptions, 'table'>) => 
          client.create({ ...options, table: 'users' }),
        update: (options: Omit<UpdateOptions, 'table'>) => 
          client.update({ ...options, table: 'users' }),
        delete: (options: Omit<DeleteOptions, 'table'>) => 
          client.delete({ ...options, table: 'users' }),
        count: (options: Omit<CountOptions, 'table'>) => 
          client.count({ ...options, table: 'users' })
      }
    }
  }
  */
  
  return typedClient
}

/**
 * Type utility for creating field mappings from generated types
 * This helps map field names to field IDs for better type safety
 */
export interface FieldMapping {
  [fieldName: string]: {
    id: number
    type: string
    required?: boolean
  }
}

/**
 * Creates field mapping from generated app schema
 * This would be auto-generated and imported from the generated types
 */
export function createFieldMapping(
  appName: string,
  tableName: string
): FieldMapping {
  // This would be populated from generated types
  // For now, return empty mapping
  return {}
}

/**
 * Transform field names to field IDs using generated mappings
 */
export function mapFieldNamesToIds(
  data: Record<string, any>,
  fieldMapping: FieldMapping
): Record<number, any> {
  const mapped: Record<number, any> = {}
  
  for (const [fieldName, value] of Object.entries(data)) {
    const field = fieldMapping[fieldName]
    if (field) {
      mapped[field.id] = value
    } else {
      // Fallback: try to parse as field ID
      const fieldId = parseInt(fieldName)
      if (!isNaN(fieldId)) {
        mapped[fieldId] = value
      }
    }
  }
  
  return mapped
}

/**
 * Transform field IDs back to field names using generated mappings
 */
export function mapFieldIdsToNames(
  data: Record<number, any>,
  fieldMapping: FieldMapping
): Record<string, any> {
  const mapped: Record<string, any> = {}
  const idToNameMap = Object.fromEntries(
    Object.entries(fieldMapping).map(([name, field]) => [field.id, name])
  )
  
  for (const [fieldId, value] of Object.entries(data)) {
    const fieldName = idToNameMap[parseInt(fieldId)]
    if (fieldName) {
      mapped[fieldName] = value
    } else {
      // Fallback: use field ID as key
      mapped[fieldId] = value
    }
  }
  
  return mapped
} 